# important
(https://docs.docker.com/compose/rails/)
1. `docker-compose run web rails new . --force --no-deps --database=postgresql`

    * First, Compose builds the image for the web service using the Dockerfile. Then it runs rails new inside a new container, using that image. Once it’s done, you should have generated a fresh app.

    * If you are running Docker on Linux, the files rails new created are owned by root. This happens because the container runs as the root user. If this is the case, change the ownership of the new files.

    * `sudo chown -R $USER:$USER .`
        * If you are running Docker on Mac or Windows, you should already have ownership of all files, including those generated by rails new.
        * (<https://github.com/utkunx/learn-linux/blob/master/linux-guides-docs/problems.md)>

    * ## Now that you’ve got a new `Gemfile`, you need to build the image again. (This, and changes to the `Gemfile` or the `Dockerfile`, should be the only times you’ll need to rebuild.)

    * # l

2. `docker-compose build`
3. `docker-compose up`
------------------
---------------
---------------
---------------
------------
# `docker-compose`

1. `docker-compose up --build` ****
    * If you make changes to the Dockerfile that the image is based on and want the image to have them, you can just add the --build tag to up instead of manually deleting the image and rerunning.

2. So basically ; (1 = `docker-compose`, 2 = `build:`, 3 = `Dockerfile:`)
    1. `docker-compose` build will read your `docker-compose.yml`, look for all services containing the
    2. `build:` statement and run a `docker build` for each one.
    3. Each build: can specify a `Dockerfile`, a context and args to pass to docker.

3. Sample example ;

    ```docker-compose.yml
        version: '3.2'

        services:
            database:
                image: mariadb
                restart: always
                volumes:
                    - ./.data/sql:/var/lib/mysql

            web:
                build:
                dockerfile: Dockerfile-alpine
                context: ./web
                ports:
                    - 8099:80
                depends_on:
                    - database
    ```
    1. When calling `docker-compose build`, only the `web` target will need an image to be `built`. The `docker build` command would look like :
    2. `docker build -t web_myproject -f Dockerfile-alpine ./web`
    3. `web` comes from the `container` name. `myproject` is the name of the `folder` you're in. This avoids conflicts if you work on two projects both containing a web container.

--------------------
* `docker-compose build`
    * The following only builds the images, does not start the containers:

* `docker-compose up`
    * The following builds the images if the images do not exist and starts the containers:
    * will only build the image if it doesn't already exist. If you make changes to the Dockerfile that the image is based on and want the image to have them, you can just add the --build tag to up instead of manually deleting the image and rerunning.

* `docker-compose up --build`
    * If you add the --build option, it is forced to build the images even when not needed:

* `docker-compose up --no-build`
    * The following skips the image build process:
        * If the images aren't built beforehand, it fails.
        * The `--no-cache option` disables the Docker build cache in the image creation process. This is used to cache each layer in the Dockerfile and to speed up the image creation reusing layers (~ Dockerfile lines) previously built for other images that are identical.

* `docker-compose up -d`
    * starts the containers in the background and leaves them running.

* `docker-compose start`
    * Starts existing containers for a service.

# Terminology

* Images - The file system and configuration of our application which are used to create containers. To find out more about a Docker image, run docker inspect alpine. In the demo above, you used the docker pull command to download the alpine image. When you executed the command docker run hello-world, it also did a docker pull behind the scenes to download the hello-world image.
* `Containers` - Running instances of `Docker images` — containers run the actual applications. A `container` includes an application and all of its dependencies. It shares the kernel with other containers, and runs as an isolated process in user space on the host OS. You created a container using docker run which you did using the alpine image that you downloaded. A list of running containers can be seen using the `docker ps` command.
* Docker daemon - The background service running on the host that manages building, running and distributing Docker containers.
* Docker client - The command line tool that allows the user to interact with the Docker daemon.
* Docker Store - A registry of Docker images, where you can find trusted and enterprise ready containers, plugins, and Docker editions. You'll be using this later in this tutorial.
